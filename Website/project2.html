<!DOCTYPE HTML>
<html>
	<head>
		<title>Project 2</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="assets/css/main.css" />
		<!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
	</head>
	<body class="no-sidebar">
		<div id="page-wrapper">

			<!-- Header -->
				<div id="header-wrapper">
					<div id="header">

						<!-- Logo -->
							<h1><a href="index.html">Project 2</a></h1>

						<!-- Nav -->
							<nav id="nav">
								<ul>
									<li><a href="index.html">Home</a></li>
									<li><a href="project1.html">Project 1</a></li>
									<li class="current"><a href="project2.html">Project 2</a></li>
									<li><a href="project3.html">Project 3</a></li>
								</ul>
							</nav>

					</div>
				</div>

			<!-- Main -->
				<div id="main-wrapper">
					<div class="container">

						<!-- Content -->
							<article class="box post">
								
								<a href="#" class="image featured"><img src="images/tron.jpg" alt="" /></a>
								<header>
									<h2>Project 2</h2>
								</header>

								<section>
									<header>
										<h3>Introduction</h3>
									</header>
									<p>
										The goal of project 2 is to implement, and test a priority based, preemptive, multithreaded real time operating system (RTOS). This is done on the same microcontroller as in project 1, the ATMega 2560. The RTOS will have similar features to the pthread library including mutexes and priority inheritence.
									</p>
								</section>

								<section>
									<header>
										<h3>Hardware</h3>
									</header>
									<h4>Arduino ATMega 2560</h4>
									<a class="image paragraph"><img src="images/mega2560.jpg"></a>
									<p>
										The ATMega 2560 is an Atmel 8-bit AVR RISC based microcontroller with 256 KB of flash memory and 8 KB of SDRAM running at 16MHz. 
									</p>
									<h4>17-Bit Address Problem</h4>
									<p>
										AVR architectures store instructions in the flash part of memory. This memory is normally accessed by 2 byte words that are addressed with 16 bit addresses. This means the maximum amount of memory that can be addressed by 16 bits is 2*2^16 bytes, or 128 KB. Since the ATMega has 256 KB of flash, it uses extended addressing to address the upper part of memory. This means the CPU effectively uses a 17 bit address, with an extra bit stored in the EIND (extended indirect) register. The compiler then calls functions in memory using special instructions (like eijmp and eicall), that concatenate the EIND register with the 16 bit Z (r30 and r31) register that stores the the first 16 bits of the address.

										In order to fix the 17-bit address problem in the RTOS, the RTOS needs to store the EIND register when it saves a task's context, and restore the EIND register when it restores a task's context. Also when the workspace for a task is initialized, there needs to be a 3 byte (instead of a 2 byte) return address for the program counter. Context switching will be illustrated later, but these two fixes are shown below:
									</p>
									<a class="image paragraph"><img src="images/17-bit-problem1.png"></a>
									<br>
									<a class="image paragraph"><img src="images/17-bit-problem2.png"></a>
									<br>
									<p>
										As you can see, the third byte is set to 0 when the task is initialized.
									</p>
								</section>

								<section>
									<header>
										<h3>RTOS Design</h3>
									</header>

									<h4>Booting, Context Switching, and the Kernel</h4>
									<b>RTOS Booting</b>
									<p>
										When the RTOS boots, it makes a one-time call to OS_Init, which initializes all of the important counts and memory allocations necessary for operation.

										In this RTOS, threads are represented by "tasks". Each task is represented by a process descriptor, which contains all location and state information about each task. In addition, each process descriptor contains a memory "workspace" of 256 bytes for storing the register values and return address for context-switching. Memory for 16 (MAXTHREAD) of these processes is allocated upon initial booting of the RTOS. 

										Likewise, memory is allocated for 8 Mutexes and 8 Events (both of which are covered in later sections).
									</p>

									<b>Timers and Interrupts</b>
									<p>
										Two of the 16-bit PWM timers on the ATMega2560 were used to control the flow of the RTOS. Both were configured in CTC (Clear Timer on Compare) mode with TOP values to control the rate at which their relative timer compare-vectors were set. Interrupt handlers were then created for the periodic interrupts that occurred. 

										For Timer 3, the OCR (Output Compare Register) was set so that an interrupt would fire every second, and increment a continuous count that tracks the number of seconds since the beginning of program execution. This count is necessary for properly sleeping tasks (explained in a later section). Timer 1 was set so that an interrupt would occur every 10ms, calling an ISR to periodically checki the SleepQueue for tasks that were due to be set READY again, dequeued from the SleepQueue, and enqueued into the ReadyQueue. This ISR would then also always call Task_Next.
									</p>

									<b>The Kernel</b>
									<p>
										Lorem Ipsum.  
									</p>

									<b>a_main?</b>
									<p>
										Lorem Ipsum?  
									</p>
									
									<h4>Priority Scheduling</h4>
									<b>Dispatch</b>
									<p>
										Lorem Ipsum.
									</p>

									<h4>Tasks</h4>
									<b>Overview</b>
									<p>
										As mentioned in RTOS Booting, each task is represented by a process descriptor...
									</p>
									<b>Task Next</b>
									<p>
										Task_Next sets the kernel request to NEXT and enters the kernel. The kernel simply sets the current state to READY, enqueues the current process into the ReadyQueue, and calls Dispatch.
									</p>
									<b>Task Create</b>
									<p>
										Task_Create is called with three parameters: a pointer to the function that is to run as the task, an integer value for the initial priority of the task, and an integer value for the task's "arg". 
									</p>

									<b>Task GetArg</b>
									<p>
										Lorem Ipsum.
									</p>

									<b>Task Suspend</b>
									<p>
										Lorem Ipsum.
									</p>

									<b>Task Resume</b>
									<p>
										Lorem Ipsum.
									</p>

									<b>Task Sleep</b>
									<p>
										Lorem Ipsum.
									</p>

									<b>Task Terminate</b>
									<p>
										Lorem Ipsum.
									</p>

									<h4>Mutexes and Priority Inheritence</h4>
									<b>Overview</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Mutex Lock</b>
									<p>
										Lorem Ipsum.
									</p>

									<b>Mutex Unlock</b>
									<p>
										Lorem Ipsum.
									</p>

									<h4>Events</h4>
									<b>Overview</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Event Wait</b>
									<p>
										Lorem Ipsum.
									</p>

									<b>Event Signal</b>
									<p>
										Lorem Ipsum.
									</p>

									<h4>Error Handling</h4>
									<b>Recoverable Errors</b>
									<p>
										Lorem Ipsum.
									</p>

									<b>Unrecoverable Errors</b>
									<p>
										Lorem Ipsum.
									</p>
								</section>

								<section>
									<header>
										<h3>Testing and Profiling</h3>
									</header>

									<h4>Initial Tests</h4>
									<b>Test 1</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 2</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 3</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 4</b>
									<p>
										Lorem Ipsum.
									</p>

									<h4>Task Termination</h4>
									<b>Test 1</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 2</b>
									<p>
										Lorem Ipsum.
									</p>

									<h4>Suspend &amp; Resume</h4>
									<b>Test 1</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 2</b>
									<p>
										Lorem Ipsum.
									</p>

									<h4>Task Sleep</h4>
									<b>Test 1</b>
									<p>
										Lorem Ipsum.
									</p>

									<h4>Mutexes</h4>
									<b>Test 1</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 2</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 3</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 4</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 5</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 6</b>
									<p>
										Lorem Ipsum.
									</p>

									<h4>Events</h4>
									<b>Test 1</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 2</b>
									<p>
										Lorem Ipsum.
									</p>
									<b>Test 3</b>
									<p>
										Lorem Ipsum.
									</p>
								</section>

								<section>
									<header>
										<h3>RTOS Performance Measurements</h3>
									</header>
									<p>
										Performance measurements were collected using a USB logic analyzer and setting a pin high when entering the specific piece of code to be instrumented. The pin would then be set low when the desired piece of code had finished executing. The following sections show the logic analyzer outputs and measured times:
									</p>
									<b>Boot Time</b>
									<p>
										<a class="image"><img src="images/m1_boot_time.png"></a>
										The boot time refers to the amount of time it takes for the RTOS to initialize and start.
										<table>
											<tr>
                                                <td>Channel 0</td>
												<td>Boot Time = 1.942 ms</td>
											</tr>
										</table>
									</p>
									<b>Dispatch and Context Switching</b>
									<p>
                                        <a class="image"><img src="images/m2_dispatch_and_cswitch.png"></a>
										The dispatch time refers precisely to the dispatch function discussed above and measures the amount of time it takes to select a new task from the ReadyQueue to run. The context switching time is the time it takes to save the current context onto the stack, and restore a new context back into the registers. The time is the same for entering the kernel, or leaving the kernel.
                                        <table>
                                            <tr>
                                                <td>Channel 0</td>
                                                <td>Dispatch = 10.17 &mu;s</td>
                                            </tr>
                                            <tr>
                                                <td>Channel 1</td>
                                                <td>Context Switch = 13 &mu;s</td>
                                            </tr>
                                        </table>
									</p>
									<b>Worst Case Interrupt Disabled Time</b>
									<p>
										<a class="image"><img src="images/m3_worst_case_interrupt_disabled_time.png"></a>
                                        The worst case interrupt disabled time is measured as the longest time interrupts are disabled. This happens when a call to Task_Create occurs. We enter the kernel, create the task, and return back to the original task (if the original task still has the highest priority).
                                        <table>
                                            <tr>
                                                <td>Channel 0</td>
                                                <td>Worst Case Interrupt Disabled Time = 0.163 &mu;s</td>
                                            </tr>
                                        </table>
									</p>
									<b>Tasks</b>
									<p>
										<a class="image"><img src="images/m4_tasks.png"></a>
                                        The following table shows the average times for each of the actions that can take place on a task:
                                        <table>
                                            <tr>
                                                <td>Channel 0</td>
                                                <td>Task Create = 0.15 ms</td>
                                            </tr>
                                            <tr>
                                                <td>Channel 1</td>
                                                <td>Task Sleep = 56.17 &mu;s</td>
                                            </tr>
                                            <tr>
                                                <td>Channel 2</td>
                                                <td>Task Suspend = 23.58 &mu;s</td>
                                            </tr>
                                            <tr>
                                                <td>Channel 3</td>
                                                <td>Task Resume = 24.33 &mu;s</td>
                                            </tr>
                                            <tr>
                                                <td>Channel 4</td>
                                                <td>Task Terminate = 0.12 ms</td>
                                            </tr>
                                            <tr>
                                                <td>Not Displayed</td>
                                                <td>Task GetArg = 0.12 &mu;s</td>
                                            </tr>
                                        </table>
									</p>
									<b>Mutexes</b>
									<p>
										<a class="image"><img src="images/m5_mutex.png"></a>
                                        The following table shows the average times for each of the actions that can take place on a mutex:
                                        <table>
                                            <tr>
                                                <td>Channel 0</td>
                                                <td>Mutex Lock = 20.5 &mu;s</td>
                                            </tr>
                                            <tr>
                                                <td>Channel 1</td>
                                                <td>Mutex Unlock = 28.17 &mu;s</td>
                                            </tr>
                                        </table>
									</p>
                                    <b>Events</b>
                                    <p>
                                        <a class="image"><img src="images/m6_events.png"></a>
                                        The following table shows the average times for each of the actions that can take place on an event:
                                        <table>
                                            <tr>
                                                <td>Channel 0</td>
                                                <td>Event Wait = 30 &mu;s</td>
                                            </tr>
                                            <tr>
                                                <td>Channel 1</td>
                                                <td>Event Signal = 23 &mu;s</td>
                                            </tr>
                                        </table>
                                    </p>
								</section>

								<section>
									<header>
										<h3>Future Improvements</h3>
									</header>
									<h4>Improve Interrupt Service Routine</h4>
									<p>
										Currently the interrupt service routine (ISR) fires every 10 ms to check the SleepQueue and potentially dispatch a new task. Currently if a new task is dispatched, the ISR does not finish its execution and leaves a return address on the stack. One improvement to this is to instead use the eijmp (extended indirect jump) instruction to leave the ISR and enter the kernel without leaving a return address on the stack. This would slightly improve performance and make sure the ISR finishes its execution.
									</p>
									<h4>Reduce CPU Power Consumption</h4>
                                    <p>
                                        A way to improve the battery life of any applicaiton running on this RTOS is to put the CPU into a low power mode if there is no task to execute. This can be done using the AVR sleep library. The idea would be to find a way to estimate how long the CPU plans to be idle, and if it was worth it, sleep for that amount of time. Calculations would have to be performed to detemine the overhead of putting the CPU to sleep and waking it up. With that information, an informed decision could be made to sleep the CPU if it is going to be idle for more than t milliseconds.
                                    </p>
                                    <h4>Improving Core RTOS Performance</h4>
                                    <p>
                                        Other cleanup and improvements for this RTOS is to improve the queue data structure. Currently, either one of dequeue or queue is an O(n) operation, while the other is O(1). They can both be made O(1) operations by revising the queueing/dequeueing strategy or using a hash table instead.
                                    </p>
								</section>

								<section>
									<header>
										<h3>References</h3>
									</header>
									<ul>
										<li></li>
									</ul>
								</section>

								<section>
									<header>
										<h3>Code</h3>
									</header>
									<p>
										Download the project 2 source code <a href="http://www.roombatank.com/project2.zip">here</a>.
									</p>
								</section>

							</article>
					</div>
				</div>

			<!-- Footer -->
				<div id="footer-wrapper">
					<section id="footer" class="container">
						<div class="row">
							<div class="12u">

								<!-- Copyright -->
									<div id="copyright">
										<ul class="links">
											<li>ROOMBA TANK &copy; 2016</li>
										</ul>
									</div>

							</div>
						</div>
					</section>
				</div>

		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/skel-viewport.min.js"></script>
			<script src="assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="assets/js/main.js"></script>

	</body>
</html>