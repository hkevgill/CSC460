<!DOCTYPE HTML>
<html>
	<head>
		<title>Project 3</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="assets/css/main.css" />
		<!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
	</head>
	<body class="no-sidebar">
		<div id="page-wrapper">

			<!-- Header -->
				<div id="header-wrapper">
					<div id="header">

						<!-- Logo -->
							<h1><a href="index.html">Project 3</a></h1>

						<!-- Nav -->
							<nav id="nav">
								<ul>
									<li><a href="index.html">Home</a></li>
									<li><a href="project1.html">Project 1</a></li>
									<li><a href="project2.html">Project 2</a></li>
									<li class="current"><a href="project3.html">Project 3</a></li>
								</ul>
							</nav>

					</div>
				</div>

			<!-- Main -->
				<div id="main-wrapper">
					<div class="container">

						<!-- Content -->
							<article class="box post">
								<a href="#" class="image featured"><img src="images/terminate.jpg" alt="" /></a>
								<header>
									<h2>Project 3</h2>
								</header>

								<section>
									<h3>Contents</h3
									<ul class="bulleted">
										<li> <a href="#Introduction">Introduction</a> </li>
										<li> <a href="#Hardware">Hardware</a> </li>
										<li> <a href="#Design">Design</a> </li>
										<li> <a href="#Implementation">Implementation</a> </li>
										<li> <a href="#Testing">Testing</a> </li>
                                        <li> <a href="#Discussion">Discussion</a> </li>
										<li> <a href="#Conclusion">Conclusion</a> </li>
                                        <li> <a href="#Demos">Demos</a> </li>
										<li> <a href="#References">References</a> </li>
                                        <li> <a href="#Appendix">Appendix</a> </li>
										<li> <a href="#Code">Code</a> </li>
									</ul>
								</section>

								<section id="Introduction">
									<header>
										<h3>Introduction</h3>
									</header>
									<p>
										The goal of project 3 is to use the sensors and actuators from project 1, the real time operating system (RTOS) from project 2, and an iRobot Roomba to create a semi-autonomous laser tank capable of battling other tanks. The Roomba will be controllable through a joystick and a pushbutton for the laser. It can roam and avoid obstacles and virtual walls on its own in autonomous mode. There is also a light-sensing target on the Roomba that detects when it has been shot, in which in case it will remain stationary, as if it has been destroyed.
									</p>
								</section>

								<section id="Hardware">
									<header>
										<h3>Hardware</h3>
									</header>
									<h4>iRobot Roomba Create 2</h4>
									<a class="image paragraph"><img src="images/irobot-roomba.jpg"></a>
									<br>
									<p>
										The iRobot Roomba Create 2 is a mobile programmable robot that allows sounds, movements, and additional sensors and actuators to be added and customized.
									</p>
								</section>

								<section id="Design">
									<header>
										<h3>Design</h3>
									</header>
                                    <p>
                                        This section talks about the system design from a high level perspective using block diagrams, finite state machines, and the subsumption architecture.
                                    </p>
									<h4>System Architecture</h4>
                                    <b>Base Station</b>
									<p>
										The base station is connected to bluetooth, and two joysticks. Bluetooth provides bidirectional communication and is used to communicate with the remote station over UART. One of the joysticks is used to control the Roomba, with its pushbutton to fire the laser. The second joystick is purely used for the pushbutton to change the remote station's state from manual to semi-autonomous and vice versa. This is illustrated in the base station's block diagram:
                                        <br>
                                        <br>
										<a class="image paragraph"><img src="images/project3/Block_Base.png"></a>
									</p>
                                    <b>Remote Station</b>
                                    <p>
                                        The remote station is connected to bluetooth, the laser, the photocell array, and the Roomba, which it is mounted on. The laser emits a bright beam when the pin is set high. The photocell is read to obtain a value and determine if it has been shot, and the connection to the Roomba allows the remote station to send the Roomba commands, and receive sensor data back. The block diagram below shows the architecture of the remote station.
                                        <a class="image paragraph"><img src="images/project3/Block_Remote.png"></a> 
                                    </p>
                                    <h4>Phase 1: Manual Control</h4>
                                    <p>
                                        Phase 1 is heavily associated with behaviour based robotics. The sensors are used to directly control the actuators.
                                    </p>
                                    <b>Laser Fire</b>
                                    <p>
                                        The Fire FSM takes data from a pushbutton and turns the laser on if the state of the pushbutton is down, or off if the state is up. The following shows the connection of sensors to actuators and the finite state machine (FSM).
                                    </p>
                                    <a class="image paragraph"><img src="images/project3/Flow_Fire.png"></a>
                                    <a class="image paragraph"><img src="images/project3/FSM_Fire.png"></a>
                                    <b>Photocell</b>
									<p>
										The photocell sensor array detects spikes in light to determine if it has been shot. Every 0.5 seconds it will update a threshold value. This threshold value is the amount of light coming from the room plus a small value. If this threshold is exceeded, then we can determine that the tank has been shot. Being shot puts the Roomba into a dead state where it can't move or shoot. This is illustrated in the diagrams below.
									</p>
                                    <a class="image paragraph"><img src="images/project3/Flow_Photocell.png"></a>
                                    <a class="image paragraph"><img src="images/project3/FSM_Photocell.png"></a>
                                    <b>Movement</b>
                                    <p>
                                        The joystick is used to control the Roomba. The position of the joystick is mapped to nine different states. These states are shown in the diagram below:
                                        <br>
                                        <br>
                                        <a class="image paragraph"><img src="images/project3/Joystick_States.png"></a>
                                        These letters then map to commands:
                                        <table>
                                            <tr>
                                                <td>A</td>
                                                <td>Forward left</td>
                                            </tr>
                                            <tr>
                                                <td>B</td>
                                                <td>Forward</td>
                                            </tr>
                                            <tr>
                                                <td>C</td>
                                                <td>Forward right</td>
                                            </tr>
                                            <tr>
                                                <td>D</td>
                                                <td>Spin counterclockwise</td>
                                            </tr>
                                            <tr>
                                                <td>E</td>
                                                <td>Spin clockwise</td>
                                            </tr>
                                            <tr>
                                                <td>F</td>
                                                <td>Backwards left</td>
                                            </tr>
                                            <tr>
                                                <td>G</td>
                                                <td>Backwards</td>
                                            </tr>
                                            <tr>
                                                <td>H</td>
                                                <td>Backwards right</td>
                                            </tr>
                                            <tr>
                                                <td>X</td>
                                                <td>Stop</td>
                                            </tr>
                                        </table>
                                        The movement FSM then interprets each of these commands and tells the Roomba to drive in that direction. This FSM is shown below:
                                    </p>
                                    <a class="image paragraph"><img src="images/project3/Flow_Movement1.png"></a>
                                    <a class="image paragraph"><img src="images/project3/FSM_Movement1.png"></a>
                                    <b>Communication</b>
                                    <p>
                                        The base station needs to communicate with the remote station, and the remote station needs to communicate with both the base station and the Roomba. This is done through UART communication over USB and bluetooth. All stations can send data and receive data. This is shown in the FSM below:
                                    </p>
                                    <a class="image paragraph"><img src="images/project3/FSM_Bluetooth.png"></a>
									<h4>Phase 2: Semi-Autonomous Control</h4>
									<b>Subsumption Architecture</b>
									<p>
										Phase 2 uses the subsumption architecture. In this robotics architecture, sensors may cause the system to have different behaviour based on their state. This is accomplished by decomposing the overall behaviour into sub-behaviours. These sub-behaviours implement a degree of behavioral competence. The more important behaviours are then able to subsume less important behaviours. This can be seen from the high-level representation of our system's motor control logic:
                                        <br>
                                        <br>
										<a class="image paragraph"><img src="images/project3/Flow_Motor.png"></a>
										In the above representation, four separate FSM's govern the Roomba's motor behaviour. However, there is a subsumption hierarchy that determines which logic is actually in command. In our system, the order is: 
										<i>Laser Detection > IR Boundary Detection > Obstacle Avoidance > Movement</i>.
									</p>
                                    <b>Semi-Autonomous Movement</b>
                                    <p>
                                        When the Roomba is in semi-autonomous mode, it will travel forward, and when it detects an obstacle or virtual IR wall, it will back up, turn counterclockwise and continue onward.
                                    </p>
									<b>Updated Movement</b>
									<p>
										The Movement FSM was updated to include a pushbutton input that toggles the state of AUTO between 1 and 0. In addition to the functionality from Phase 1, the system now only continues forward when AUTO is set to 1. The change can be seen in the following diagrams:
									</p>
									<a class="image paragraph"><img src="images/project3/Flow_Movement2.png"></a>
									<a class="image paragraph"><img src="images/project3/FSM_Movement2.png"></a>
									<b>IR-Wall Detection</b>
									<p>
										The IR-Wall Detection FSM uses the Roomba sensor data and sends a movement command if an IR-Wall is detected. The command sent depends on the current movement state, and is the reverse of the current movement state. The mapping of current states to movement commands is shown in the table below:
                                        <table>
                                            <tr>
                                                <td>A</td>
                                                <td>Backwards left</td>
                                            </tr>
                                            <tr>
                                                <td>B</td>
                                                <td>Backwards</td>
                                            </tr>
                                            <tr>
                                                <td>C</td>
                                                <td>Backwards right</td>
                                            </tr>
                                            <tr>
                                                <td>D</td>
                                                <td>Spin clockwise</td>
                                            </tr>
                                            <tr>
                                                <td>E</td>
                                                <td>Spin counterclockwise</td>
                                            </tr>
                                            <tr>
                                                <td>F</td>
                                                <td>Forward left</td>
                                            </tr>
                                            <tr>
                                                <td>G</td>
                                                <td>Forward</td>
                                            </tr>
                                            <tr>
                                                <td>H</td>
                                                <td>Forward right</td>
                                            </tr>
                                            <tr>
                                                <td>X</td>
                                                <td>Backwards</td>
                                            </tr>
                                        </table>
                                        The movement FSM then interprets each of these commands and tells the Roomba to drive in that direction. If the Roomba is currently in autonomous mode (ie: AUTO = 1), the Roomba will then briefly turn in place. This FSM is shown below:
									</p>
									<a class="image paragraph"><img src="images/project3/Flow_IR_Boundary.png"></a>
									<a class="image paragraph"><img src="images/project3/FSM_IR_Boundary.png"></a>
									<b>Obstacle Avoidance</b>
									<p>
										The Obstacle Avoidance FSM takes Roomba sensor data and determines if an obstacle has been hit by the Roomba's front bumpers. If this is the case, the Roomba will drive backwards for 200ms. In addition, if the Roomba is currently in autonomous mode (ie: AUTO = 1), the Roomba will then briefly turn in place. This FSM is shown below:
									</p>
									<a class="image paragraph"><img src="images/project3/Flow_Obstacle.png"></a>
									<a class="image paragraph"><img src="images/project3/FSM_Obstacle.png"></a>

                                    <h4>Task Decomposition</h3>
                                    <p>The above functionality is broken down into tasks that will run on the RTOS. Each task has its own scheduling parameters (priority and frequency). A priority of 0 represents the highest, whereas a priority of 10 is the lowest.</p>
                                    <b>Base Station Tasks</b>
                                    <p>
                                        <table>
                                            <tr>
                                                <td><b>Task</b></td>
                                                <td><b>Description</b></td>
                                                <td><b>Priority, Frequency</b></td>
                                            </tr>
                                            <tr>
                                                <td>SwitchTask</td>
                                                <td>Switches between autonomous and manual mode</td>
                                                <td>2, 20ms</td>
                                            </tr>
                                            <tr>
                                                <td>LaserTask</td>
                                                <td>Reads the pushbutton and sends the data to fire the laser</td>
                                                <td>2, 10ms</td>
                                            </tr>
                                            <tr>
                                                <td>screenTask</td>
                                                <td>Checks if any data is ready to be displayed on the LCD</td>
                                                <td>2, 15ms</td>
                                            </tr>
                                            <tr>
                                                <td>bluetoothReceive</td>
                                                <td>Receives incoming data from the remote station</td>
                                                <td>2, 15ms</td>
                                            </tr>
                                            <tr>
                                                <td>RoombaTask</td>
                                                <td>Reads x and y from joystick and maps it to Roomba states</td>
                                                <td>2, 20ms</td>
                                            </tr>
                                            <tr>
                                                <td>Idle</td>
                                                <td>Runs when no other task is available</td>
                                                <td>10, No other taks</td>
                                            </tr>
                                        </table>
                                    </p>
                                    <b>Remote Station Tasks</b>
                                    <p>
                                        <table>
                                            <tr>
                                                <td><b>Task</b></td>
                                                <td><b>Description</b></td>
                                                <td><b>Priority, Frequency</b></td>
                                            </tr>
                                            <tr>
                                                <td>Bluetooth_Receive</td>
                                                <td>Receives incoming data from the base station</td>
                                                <td>1, 5ms</td>
                                            </tr>
                                            <tr>
                                                <td>Bluetooth_Send</td>
                                                <td>Sends lightsensor data to the base station</td>
                                                <td>2, 10ms</td>
                                            </tr>
                                            <tr>
                                                <td>Laser_Task</td>
                                                <td>Turns the laser on or off depending on the pushbutton</td>
                                                <td>2, 10ms</td>
                                            </tr>
                                            <tr>
                                                <td>LightSensor_Task</td>
                                                <td>Reads the lightsensor value to determine if it has been shot</td>
                                                <td>2, 10ms</td>
                                            </tr>
                                            <tr>
                                                <td>Roomba_Task</td>
                                                <td>Determines the next move for the Roomba</td>
                                                <td>2, 20ms</td>
                                            </tr>
                                            <tr>
                                                <td>Get_Sensor_Data</td>
                                                <td>Requests bumper and virtual wall data from the Roomba</td>
                                                <td>2, 20ms</td>
                                            </tr>
                                            <tr>
                                                <td>Idle</td>
                                                <td>Runs when no other task is available</td>
                                                <td>10, 10, No other taks</td>
                                            </tr>
                                        </table>
                                    </p>
								</section>

								<section id="Implementation">
									<header>
										<h3>Implementation</h3>
									</header>
                                    <h4>RTOS</h4>
                                    <p>
                                        The RTOS from project 2 is running on both the base and remote station. The stations do not use all of the features of the RTOS, but they use task creation, sleep, termination, and mutex lock and unlock. Thus the code does have critical sections that are protected by mutexes, and tasks that are put to sleep and woken up.
                                    </p>
                                    <h4>UART</h4>
                                    <p>
                                        The UART library is used to transfer data across bluetooth, and to and from the Roomba. There are four commands for bluetooth and the Roomba and they are: UART_Init, Send_Byte, Receive_Byte, and Send_String. Bluetooth uses UART1 and the Roomba uses UART3. The first byte sent over bluetooth is always a flag indicating which actuator the data is meant for, then the remaining data is sent. The Roomba functions similarly with the first byte usually being a special opcode define in the OI.
                                    </p>
                                    <b>UART_Init</b>
                                    <p>
                                        UART_Init sets the baud rate to 19.2k, enables the receiver and transmitter, specifies that 8 bit data will be transferred, and disables double speed.
                                    </p>
                                    <b>Send_Byte</b>
                                    <p>
                                        Send_Byte takes in 8 bits of data, waits for an empty transmit buffer, then puts the data into the buffer.
                                    </p>
                                    <b>Receive_Byte</b>
                                    <p>
                                        Receive_Byte waits for data to be received, then returns the byte.
                                    </p>
                                    <b>Send_String</b>
                                    <p>
                                        Send_String takes a character array and sends one character at a time until the entire array has been sent.
                                    </p>
                                    <h4>Roomba</h4>
                                    <p>
                                        The Roomba library is used to initialize the Roomba, drive the Roomba, Query the sensors, and load a song.
                                    </p>
                                    <b>Roomba_Init</b>
                                    <p>
                                        Roomba_Init wakes the Roomba from sleep, Starts the open interface (OI), waits 2 seconds, then pulses the DD pin three times to set the baud rate to 19.2k. Then the Roomba is put into safe mode and a song 0 is initialized.
                                    </p>
                                    <b>Roomba_Drive</b>
                                    <p>
                                        Roomba_Drive takes in a 16 bit velocity and a 16 bit radius, and sends them to the Roomba for execution.
                                    </p>
                                    <b>Roomba_Play</b>
                                    <p>
                                        Roomba_Play takes a song number and plays the song.
                                    </p>
                                    <b>Roomba_Sensors</b>
                                    <p>
                                        Roomba_Sensors takes a packet_id and returns the data from the specified sensor.
                                    </p>
                                    <b>Roomba_QueryList</b>
                                    <p>
                                        Roomba_QueryList takes two parameters and requests two sensor data packets back. The data arrives in the same order it was sent.
                                    </p>
                                    <b>Roomba_Song</b>
                                    <p>
                                        Roomba_Song loads a song onto the Roomba by sending the song number, 6 notes, and the duration each note should be played in 1/64ths of a second.
                                    </p>
                                    <h4>Queues</h4>
                                    <p>
                                        The queue data structure is used to hold data that comes in over bluetooth. The bluetooth receive functions put the data for each actuator into the right queue. There is an lsQueue (light sensor queue) on the base station, and a laserQueue and roombaQueue on the remote station. The independent functions can then check these queues to see if new data has become available. The queues are circular and keep track of a front and rear pointer. They are all a fixed size of 10, which with a circular queue gives 9 spaces. The functions available are buffer_isEmpty, buffer_isFull, buffer_enqueue, and buffer_dequeue. Because of the rear and front pointers, enqueue and dequeue are both O(1) operations.
                                    </p>
                                    <h4>Base Station</h4>
									<p>
										The base station is implemented using five tasks and an idle task. These tasks are LaserTask, RoombaTask, bluetoothReceive, screenTask, and SwitchTask. The a_main task that is created by the RTOS creates these tasks, initializes the bluetooth_mutex, adc_mutex, ls_mutex, initializes A to D conversion, initializes bluetooth, and then terminates itself.
									</p>
                                    <b>Mutexes</b>
                                    <p>
                                        The adc_mutex is locked when an A to D conversion begins, and is unlocked when it finishes. This prevents any conversions from being interrupted and cancelled.The bluetooth_mutex is locked when data needs to be sent, and then unlocked when the data has sent. This is to prevent a task that is sending data from being interrupted part way through and having another task start sending data. The ls_mutex is locked anytime the lsQueue (light sensor queue) is accessed.
                                    </p>
                                    <b>LaserTask</b>
                                    <p>
                                        The LaserTask reads the digital pin from the pushbutton on the joystick and if the state has changed, sends the new state to the remote station so that it can update the laser. LaserTask then goes to sleep for 10 ticks (100ms) and therefore has a frequency of 10Hz.
                                    </p>
                                    <b>RoombaTask</b>
                                    <p>
                                        RoombaTask locks the adc mutex, then does two A to D conversions to get the x and y values from the joystick and unlocks the mutex. It then maps these values to the characters A, B, C, ... , H, X shown above in the design section. The correct state is then sent to the remote station and this task will sleep for 20 ticks (200ms).
                                    </p>
                                    <b>bluetoothReceive</b>
                                    <p>
                                        If there is data available to receive, then this task reads the data and checks to see if the first byte is the light sensor flag indicating light sensor data is incoming. If it is, two more bytes are read and put together into a 16 bit integer. The ls_mutex is locked and this integer is enqueued into the light sensor queue, then the ls_mutex is unlocked. This task then sleeps for 15 ticks (150ms).
                                    </p>
                                    <b>screenTask</b>
                                    <p>
                                        screenTask locks the ls_mutex and dequeues an element from the buffer if one is available. This is all this task does for now, eventually it would display on an LCD screen on the base station. The ls_mutex is then unlocked. screenTask then sleeps for 15 ticks (150ms).
                                    </p>
                                    <b>SwitchTask</b>
                                    <p>
                                        SwitchTask reads the digital pin the other joystick pushbutton is connected to. If the button has been pushed, it sends a byte to the remote station that indicates it needs to change states. The two possible states are autonomous or manual. This task then sleeps for 20 ticks (200ms).
                                    </p>
                                    <h4>Remote Station</h4>
                                    <p>
                                        The remote station is implemented using 6 tasks and an idle task.
                                    </p>
								</section>

								<section id="Testing">
									<header>
										<h3>Testing</h3>
									</header>
									<p>
										Testing was conducted to evaluate whether the applications behaviour matched the expected criteria. Testing was split into four distinct categories. These categories are manuel control and laser, IR boundary and obstacle avoidance, semi-autonomous, and light detection.
									</p>
									<h4>Manual Control and Firing</h4>
									<p>
										<table>
											<tr>
												<td>Objective:</td>
												<td>To test that the joystick movements are correctly mapped, sent over bluetooth, and translated into Roomba drive commands to control the Roomba.</td>
											</tr>
											<tr>
												<td>Description:</td>
												<td>Moving the joystick up and down makes the Roomba go straight forward and straight backwards. Moving the joystick left causes the Roomba to spin counterclockwise, moving right causes the Roomba to spin clockwise. Moving the joystick to the top left corner causes the Roomba to travel forwards and counterclockwise, the top right corner causes it to travel forwards and clockwise, the bottom left causes it to travel backwards and clockwise, and the bottom right to travel backwards and counterclockwise.</td>
											</tr>
											<tr>
												<td>Results:</td>
												<td>As shown in the video below, the Roomba responds quickly and effectively to the expected behaviour</td>
											</tr>
										</table>
									</p>
									<video width="640" height="400" controls>
										<source src="videos/manual_and_laser.mov" type="video/mp4">
										Your browser does not support the video tag.
									</video>
									<h4>IR Boundary and Obstacle Avoidance in Manual Mode</h4>
									<p>
										<table>
											<tr>
												<td>Objective:</td>
												<td>This test has two purposes. The first is to make sure the Roomba does not cross any virtual walls by backing up when the wall is detected. The second is to back up when the Roomba runs into an obstacle with the bumper.</td>
											</tr>
											<tr>
												<td>Description:</td>
												<td>When the Roomba runs into an obstacle with the bumper, it will travel straight backwards to back away from the object so that the user can then attempt to avoid the obstacle. The same occurs for the virtual wall.</td>
											</tr>
											<tr>
												<td>Results:</td>
												<td>As shown in the video below, the Roomba backs away when the bumper is hit, or the virtual wall is detected.</td>
											</tr>
										</table>
									</p>
									<video width="640" height="400" controls>
										<source src="videos/bumper_and_ir.mov" type="video/mp4">
										Your browser does not support the video tag.
									</video>
									<h4>Semi-Autonomous Control</h4>
									<p>
										<table>
											<tr>
												<td>Objective:</td>
												<td>This test has four purposes. The first is to make that the Roomba can switch from manual to semi-autonomous mode and vice versa. The second is to verify that while in semi-autonomous mode, the Roomba travels forward. The third tests that if a virtual wall is detected, the Roomba will backup, turn counterclockwise, and then continue forward. The fourth shows that when an obstacle is hit the roomba backs up, turns counterclockwise, and continues as well.</td>
											</tr>
											<tr>
												<td>Description:</td>
												<td>The video starts by switching from manual mode to semi-autonomous mode. Then the Roomba travels into the virtual wall and turns counterclockwise. Once the Roomba hits the real wall, it also turns clockwise. The video ends by using the button to switch back to manual mode. The virtual wall emitter is enclosed by two red cups in order to emit a more focused beam.</td>
											</tr>
											<tr>
												<td>Results:</td>
												<td>As shown in the video below, the Roomba successfully switches modes, avoids the virtual wall, and bounces off the real wall, and successfully returns to manual mode.</td>
											</tr>
										</table>
									</p>
									<video width="640" height="400" controls>
										<source src="videos/autonomous.mov" type="video/mp4">
										Your browser does not support the video tag.
									</video>
									<h4>Light Detection</h4>
									<p>
										<table>
											<tr>
												<td>Objective:</td>
												<td>To test that the light sensor successfully detects a laser and registers it as a hit.</td>
											</tr>
											<tr>
												<td>Description:</td>
												<td>When a laser is shined on the light sensor, the Roomba (the one on the left) will play a sound to indicate that it was hit, turn off its laser, stop moving, and be in a dead state.</td>
											</tr>
											<tr>
												<td>Results:</td>
												<td>As shown in the video below, the Roomba successfully stops moving, has its laser off, and can no longer be controlled until it is reset.</td>
											</tr>
										</table>
									</p>
									<video width="640" height="400" controls>
										<source src="videos/light_detection.mov" type="video/mp4">
										Your browser does not support the video tag.
									</video>
								</section>

                                <section id="Discussion">
                                    <header>
                                        <h3>Discussion</h3>
                                    </header>
                                    <p>
                                        Discuss...
                                    </p>
                                </section>

								<section id="Conclusion">
									<header>
										<h3>Conclusion</h3>
									</header>
									<p>
										A semi-autonomous laser tank was created using the sensors and actuators from project 1, the RTOS from project 2, the ATMega 2560 microcontroller, and the iRobot Roomba Create 2. The tank's movement can be operated manually or autonomously, while the laser is always controlled by the pushbutton on the joystick. The light sensor detects the light of the room using averaging and detects bursts in the light to determine whether it has been hit. This concludes our making of a Roomba laser tank.
									</p>
								</section>

                                <section id="Demos">
                                    <header>
                                        <h3>Demos</h3>
                                    </header>
                                    <h4>Phase 1 Demo</h4>
                                    <p>
                                        This demo shows the Roomba being manually controller by the joystick and moving around.
                                    </p>
                                    <video width="640" height="400" controls>
                                        <source src="videos/manual_demo.mov" type="video/mp4">
                                        Your browser does not support the video tag.
                                    </video>
                                    <h4>Phase 2 Demo</h4>
                                    <p>
                                        This demo shows the Roomba operating in semi-autonomous mode. When it runs into an obstacle, it goes straight backwards, turns counterclockwise, and then continues forward again.
                                    </p>
                                    <video width="640" height="400" controls>
                                        <source src="videos/autonomous_demo.mov" type="video/mp4">
                                        Your browser does not support the video tag.
                                    </video>
                                </section>

								<section id="References">
									<header>
										<h3>References</h3>
									</header>
									<p>
										<ul>
											<li>
												The ATMega 2560 Datasheet is available <a href="http://www.atmel.com/images/atmel-2549-8-bit-avr-microcontroller-atmega640-1280-1281-2560-2561_datasheet.pdf">here</a>.
											</li>
											<li>
												The iRobot Roomba Create 2 Open Interface is available <a href="http://www.irobot.com/~/media/MainSite/PDFs/About/STEM/Create/create_2_Open_Interface_Spec.pdf">here</a>.
											</li>
										</ul>
									</p>
								</section>

                                <section id="Appendix">
                                    <header>
                                        <h3>Appendix</h3>
                                    </header>
                                    <h4>Base Station Wiring Diagram</h4>
                                    <p>
                                        One of the joysticks only has the digital pushbutton pin connected.
                                        <br><br>
                                        <a class="image paragraph"><img src="images/project3/fritz_project3_base_bb.png"></a>
                                    </p>
                                    <h4>Base Station Wiring Diagram</h4>
                                    <p>
                                        The four wires left unplugged are for attaching to the Roomba.
                                        <br>
                                        <br>
                                        <a class="image paragraph"><img src="images/project3/fritz_project3_remote_bb.png"></a>
                                    </p>
                                </section>

								<section id="Code">
									<header>
										<h3>Code</h3>
									</header>
									<p>
										The code API as generated by Doxygen is available <a href="doxygen/html/index.html">here</a>.
										<br>
										You can download the project 3 source code <a href="http://www.roombatank.com/project3.zip">here</a>.
									</p>
								</section>

							</article>

					</div>
				</div>

			<!-- Footer -->
				<div id="footer-wrapper">
					<section id="footer" class="container">
						<div class="row">
							<div class="12u">

								<!-- Copyright -->
									<div id="copyright">
										<ul class="links">
											<li>ROOMBA TANK &copy; 2016</li>
										</ul>
									</div>

							</div>
						</div>
					</section>
				</div>

		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/skel-viewport.min.js"></script>
			<script src="assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="assets/js/main.js"></script>

	</body>
</html>